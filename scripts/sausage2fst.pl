#!/usr/bin/perl
# Converting a confusion network generated by SRILM to FST (OpenFST) text format

use strict;
use Env qw(REMOVE_EPSILON_TRANSITIONS);
use Env qw(FORCE_EPSILON_TRANSITIONS);
use Env qw(FORCE_EPSILON_TRANSITION_LOGPROB);

if (!defined $FORCE_EPSILON_TRANSITIONS) {
	$FORCE_EPSILON_TRANSITIONS = 0;
} else {
#	print STDERR "FORCE_EPSILON_TRANSITIONS\n";
}

if (!defined $FORCE_EPSILON_TRANSITION_LOGPROB) {
	$FORCE_EPSILON_TRANSITION_LOGPROB = -100;
}

while (<STDIN>) {
	chomp;
	if ($_ =~ /^align /) {
#		print "$_\n";
		my @a = split(/\s+/,$_);
		shift @a;
		my $align_id = shift @a;

		my $num_hyps = scalar(@a) / 2;
		my $num_hyps_nodelete = $num_hyps - ($_ =~ /\*DELETE\*/ ? 1 : 0);

		if ($a[0] eq "<s>") {
			next;
		} elsif ($a[0] eq "</s>") {
			print "".($align_id-1)."\n";
			last;
		} else {
			my $contains_epsilon_transition = 0;
			for (my $i = 0; $i < scalar(@a); $i+=2) {
				my $word = $a[$i];
				my $prob = $a[$i+1];
				if ($prob == 0 && scalar(@a) > 2) {
					#print STDERR "0 logprob found: $_\n";
					$prob = 1e-10;
				} else {
					$prob = -log($prob);
				}
				if ($word eq "*DELETE*") {
					if (!$REMOVE_EPSILON_TRANSITIONS) {
						$contains_epsilon_transition = 1;
						print "".($align_id-1)." $align_id <eps> <eps> $prob\n";
					}
				} else {
					$_ = <STDIN>;
					chomp;
					my @a = split(/\s+/,$_);
					my $end_time = $a[3] + $a[4];
					printf("".($align_id-1)." $align_id $word t=%.2f $prob\n", $end_time);
				}
			}
			if ($FORCE_EPSILON_TRANSITIONS && !$contains_epsilon_transition) {
				print "".($align_id-1)." $align_id <eps> <eps> ".(0-$FORCE_EPSILON_TRANSITION_LOGPROB)."\n";
			}
		}
	}
}

